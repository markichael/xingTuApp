package com.example.autobuild

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.model.ObjectFactory
import javax.inject.Inject
import java.io.File

open class AutoBuildExtension @Inject constructor(objects: ObjectFactory) {
    var cacheDir: String? = null
    var dependencyOutputFile: String? = null
}

abstract class ClearCacheTask : DefaultTask() {
    @get:org.gradle.api.tasks.Input
    abstract val directory: Property<String>

    @TaskAction
    fun run() {
        val dirPath = directory.orNull
        if (dirPath.isNullOrBlank()) {
            logger.lifecycle("[AutoBuild] ClearCacheTask skipped: no directory configured")
            return
        }
        val dir = project.file(dirPath)
        if (dir.exists()) {
            project.logger.lifecycle("[AutoBuild] Clearing cache directory: ${dir.absolutePath}")
            dir.deleteRecursively()
        } else {
            project.logger.lifecycle("[AutoBuild] Cache directory does not exist: ${dir.absolutePath}")
        }
    }
}

abstract class WriteDependencyTreeTask : DefaultTask() {
    @get:org.gradle.api.tasks.OutputFile
    abstract val outputFile: RegularFileProperty

    @TaskAction
    fun run() {
        val outFile = outputFile.asFile.get()
        outFile.parentFile.mkdirs()
        outFile.writeText(buildString {
            appendLine("# Dependency Tree for project '${project.path}'")
            appendLine("# Generated by AutoBuildPlugin")
            project.configurations.forEach { cfg ->
                if (!cfg.isCanBeResolved) return@forEach
                appendLine("\nConfiguration: ${cfg.name}")
                try {
                    val resolved = cfg.resolvedConfiguration.firstLevelModuleDependencies
                    resolved.forEach { dep ->
                        appendLine("- ${dep.moduleGroup}:${dep.moduleName}:${dep.moduleVersion}")
                        dep.children.forEach { child ->
                            appendLine("  - ${child.moduleGroup}:${child.moduleName}:${child.moduleVersion}")
                        }
                    }
                } catch (e: Exception) {
                    appendLine("(failed to resolve: ${e.message})")
                }
            }
        })
        logger.lifecycle("[AutoBuild] Dependency tree written to: ${outFile.absolutePath}")
    }
}

class AutoBuildPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        val ext = project.extensions.create("autobuild", AutoBuildExtension::class.java)

        val clearCache = project.tasks.register("autoBuildClearCache", ClearCacheTask::class.java) {
            group = "autoBuild"
            description = "Clear a configured cache directory before build"
        }

        val writeDeps = project.tasks.register("autoBuildWriteDependencyTree", WriteDependencyTreeTask::class.java) {
            group = "autoBuild"
            description = "Write resolved dependency tree to a file"
        }

        project.afterEvaluate {
            val defaultCache = File(project.buildDir, "cache_to_clear").absolutePath
            clearCache.configure {
                val configured = ext.cacheDir ?: defaultCache
                directory.set(configured)
            }

            val defaultOut = File(project.rootProject.buildDir, "reports/dependencies/dependency-tree.txt").absolutePath
            writeDeps.configure {
                val configured = ext.dependencyOutputFile ?: defaultOut
                outputFile.set(project.layout.file(project.provider { File(configured) }))
            }

            project.tasks.matching { t -> t.name == "preBuild" }.configureEach {
                dependsOn(clearCache)
            }
            project.tasks.matching { t -> t.name == "assembleRelease" || t.name == "bundleRelease" || t.name == "build" }.configureEach {
                finalizedBy(writeDeps)
            }
        }
    }
}
